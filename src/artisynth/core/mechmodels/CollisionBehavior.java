/**
 * Copyright (c) 2014, by the Authors: John E Lloyd (UBC)
 *
 * This software is freely available under a 2-clause BSD license. Please see
 * the LICENSE file in the ArtiSynth distribution directory for details.
 */
package artisynth.core.mechmodels;

import java.io.*;
import java.util.Deque;
import java.util.LinkedList;

import maspack.util.*;
import maspack.matrix.*;
import maspack.render.*;
import maspack.render.Renderer.ColorInterpolation;
import maspack.properties.*;
import artisynth.core.util.*;
import artisynth.core.modelbase.*;
import artisynth.core.mechmodels.CollisionManager.ColliderType;

/**
 * Contains information describing the appropriate collision response
 * between two bodies.
 */
public class CollisionBehavior extends CollisionComponent
   implements Renderable {

   /**
    * Specifies how the constraints are generated for handling collisions.
    */
   public enum Method {
      /**
       * Select the method most appropriate depending on whether
       * the colliding bodies are rigid or deformable.
       */
      DEFAULT,
      
      /**
       * A contact constraint is generated for each mesh vertex that
       * interpenetrates the other mesh, with the normal direction
       * determined by finding the nearest point on the opposing
       * mesh.  This method is the default for collisions involving deformable
       * bodies, and assumes that the bodies have sufficient degrees of freedom
       * (DOF) that the system is not overly constrained. Using this method for
       * collisions between rigid bodies, or low DOF deformable bodies, will
       * generally result in an overconstrained system unless the constraints
       * are either regularized using compliance (see {@link #setCompliance})
       * or constraint reduction is enabled (see {@link #setReduceConstraints}).
       */
      VERTEX_PENETRATION,
      
      /**
       * Contact constraints are generated in the same way as for {@link
       * #VERTEX_PENETRATION}, with additional constraints created for edge-edge
       * contacts. This can be useful in situations where one or both of the
       * colliding meshes are coarse and penetrating vertices may hence not
       * always be present. However, this method is experimental and not used
       * by default.
       */
      VERTEX_EDGE_PENETRATION,
      
      /**
       * Contact constraints are generated by fitting a plane to each mesh
       * penetration region and then projecting the region onto that plane.
       * Constraints are then created from points on the perimeter of this
       * projection, with the normal direction being given by the plane
       * normal. This is the default method for collision between rigid bodies
       * or low DOF deformable bodies. Trying to use this method for FEM-based
       * deformable bodies will result in an error.
       */
      CONTOUR_REGION,
      
      /**
       * Currently the same as {@link #VERTEX_PENETRATION}.
       */
      VERTEX_PENETRATION_BILATERAL,
      
      /**
       * No constraints are generated. This setting will result in
       * no collision response.
       */
      INACTIVE
   }

   /**
    * Specified what type of data should be used when drawing a color
    * map over the collision area.
    */
   public enum ColorMapType {
      /**
       * No color map should be drawn
       */
      NONE,

      /**
       * Draw a color map of the penetration depth
       */
      PENETRATION_DEPTH,

      /**
       * Draw a color map of the contact pressure
       */
      CONTACT_PRESSURE
   }

   protected RenderProps myRenderProps;

   boolean myEnabled = false;

   static double defaultFriction = 0;
   double myFriction = defaultFriction;
   PropertyMode myFrictionMode = PropertyMode.Inherited;

   static Method defaultMethod = Method.DEFAULT;
   Method myMethod = defaultMethod;
   PropertyMode myMethodMode = PropertyMode.Inherited;

   static boolean defaultBilateralVertexContact = true;
   boolean myBilateralVertexContact = defaultBilateralVertexContact;
   PropertyMode myBilateralVertexContactMode = PropertyMode.Inherited;

   ColliderType myColliderType = CollisionManager.myDefaultColliderType;
   PropertyMode myColliderTypeMode = PropertyMode.Inherited;

//   MechModel myModel = null;

   static double defaultPenetrationTol = 0.001;
   double myPenetrationTol = defaultPenetrationTol;
   PropertyMode myPenetrationTolMode = PropertyMode.Inherited;

   static double defaultCompliance = 0.0;
   double myCompliance = defaultCompliance;
   PropertyMode myComplianceMode = PropertyMode.Inherited;

   static double defaultDamping = 0.0;
   double myDamping = defaultDamping;
   PropertyMode myDampingMode = PropertyMode.Inherited;

   static double defaultAcceleration = 0;
   double myAcceleration = defaultAcceleration;
   PropertyMode myAccelerationMode = PropertyMode.Inherited;

   static double defaultRigidRegionTol = 0.0;
   double myRigidRegionTol = defaultRigidRegionTol;
   PropertyMode myRigidRegionTolMode = PropertyMode.Inherited;

   static double defaultRigidPointTol = 0.0;
   double myRigidPointTol = defaultRigidPointTol;
   PropertyMode myRigidPointTolMode = PropertyMode.Inherited;

   static boolean defaultReduceConstraints = false;
   boolean myReduceConstraints = defaultReduceConstraints;
   PropertyMode myReduceConstraintsMode = PropertyMode.Inherited;

   static boolean defaultBodyFaceContact = false;
   boolean myBodyFaceContact = defaultBodyFaceContact;
   PropertyMode myBodyFaceContactMode = PropertyMode.Inherited;

   static boolean defaultDrawIntersectionContours = false;
   boolean myDrawIntersectionContours = defaultDrawIntersectionContours;
   PropertyMode myDrawIntersectionContoursMode = PropertyMode.Inherited;

   static boolean defaultDrawIntersectionFaces = false;
   boolean myDrawIntersectionFaces = defaultDrawIntersectionFaces;
   PropertyMode myDrawIntersectionFacesMode = PropertyMode.Inherited;

   static boolean defaultDrawIntersectionPoints = false;
   boolean myDrawIntersectionPoints = defaultDrawIntersectionPoints;
   PropertyMode myDrawIntersectionPointsMode = PropertyMode.Inherited;

   static boolean defaultDrawContactNormals = false;
   boolean myDrawContactNormals = defaultDrawContactNormals;
   PropertyMode myDrawContactNormalsMode = PropertyMode.Inherited;

   static boolean defaultDrawContactForces = false;
   boolean myDrawContactForces = defaultDrawContactForces;
   PropertyMode myDrawContactForcesMode = PropertyMode.Inherited;

   static boolean defaultDrawConstraints = false;
   boolean myDrawConstraints = defaultDrawConstraints;
   PropertyMode myDrawConstraintsMode = PropertyMode.Inherited;

   static ScalarRange defaultColorMapRange = new ScalarRange();
   ScalarRange myColorMapRange = defaultColorMapRange.clone();

   static ColorInterpolation defaultColorMapInterpolation =
      ColorInterpolation.HSV;
   ColorInterpolation myColorMapInterpolation = defaultColorMapInterpolation;
   PropertyMode myColorMapInterpolationMode = PropertyMode.Inherited;

   static ColorMapType defaultDrawColorMap = ColorMapType.NONE;
   ColorMapType myDrawColorMap = defaultDrawColorMap;
   PropertyMode myDrawColorMapMode = PropertyMode.Inherited;

   static int defaultColorMapCollidableNum = 0;
   int myColorMapCollidableNum = defaultColorMapCollidableNum;
   PropertyMode myColorMapCollidableMode = PropertyMode.Inherited;

   ContactForceBehavior myForceBehavior = null;

   protected void setDefaultValues() {
      super.setDefaultValues();
      myEnabled = false;
      myFriction = defaultFriction;
      myFrictionMode = PropertyMode.Inherited;
      myMethod = defaultMethod;
      myMethodMode = PropertyMode.Inherited;
      myColliderType = CollisionManager.myDefaultColliderType;
      myColliderTypeMode = PropertyMode.Inherited;
      myBilateralVertexContact = defaultBilateralVertexContact;
      myBilateralVertexContactMode = PropertyMode.Inherited;
      myPenetrationTol = defaultPenetrationTol;
      myPenetrationTolMode = PropertyMode.Inherited;
      myCompliance = defaultCompliance;
      myComplianceMode = PropertyMode.Inherited;
      myDamping = defaultDamping;
      myDampingMode = PropertyMode.Inherited;
      myAcceleration = defaultAcceleration;
      myAccelerationMode = PropertyMode.Inherited;
      myRigidRegionTol = defaultRigidRegionTol;
      myRigidRegionTolMode = PropertyMode.Inherited;
      myRigidPointTol = defaultRigidPointTol;
      myRigidPointTolMode = PropertyMode.Inherited;
      myReduceConstraints = defaultReduceConstraints;
      myReduceConstraintsMode = PropertyMode.Inherited;
      myBodyFaceContact = defaultBodyFaceContact;
      myBodyFaceContactMode = PropertyMode.Inherited;
      myDrawIntersectionContours = defaultDrawIntersectionContours;
      myDrawIntersectionContoursMode = PropertyMode.Inherited;
      myDrawIntersectionFaces = defaultDrawIntersectionFaces;
      myDrawIntersectionFacesMode = PropertyMode.Inherited;
      myDrawIntersectionPoints = defaultDrawIntersectionPoints;
      myDrawIntersectionPointsMode = PropertyMode.Inherited;
      myDrawContactNormals = defaultDrawContactNormals;
      myDrawContactNormalsMode = PropertyMode.Inherited;
      myDrawContactForces = defaultDrawContactForces;
      myDrawContactForcesMode = PropertyMode.Inherited;
      myDrawConstraints = defaultDrawConstraints;
      myDrawConstraintsMode = PropertyMode.Inherited;
      myDrawColorMap = defaultDrawColorMap;
      myDrawColorMapMode = PropertyMode.Inherited;
      myColorMapInterpolation = defaultColorMapInterpolation;
      myColorMapInterpolationMode = PropertyMode.Inherited;
      myColorMapCollidableNum = defaultColorMapCollidableNum;
      myColorMapCollidableMode = PropertyMode.Inherited;
      setColorMapRange (defaultColorMapRange);
      myForceBehavior = null;
   }

   public static PropertyList myProps =
      new PropertyList (CollisionBehavior.class, CollisionComponent.class);

   static {
      myProps.add ("renderProps", "renderer properties", null);
      myProps.add (
         "enabled isEnabled", "true if collisions are enabled", false);
      myProps.addInheritable (
         "friction:Inherited", "friction coefficient", defaultFriction);
      myProps.addInheritable (
         "method:Inherited", "collision handling method", defaultMethod);
      myProps.addInheritable (
         "bilateralVertexContact:Inherited",
         "allow bilateral constraints for vertex-based contacts", 
         defaultBilateralVertexContact);
      myProps.addInheritable (
         "colliderType", "type of collider to use for collisions",
         CollisionManager.myDefaultColliderType);
      myProps.addInheritable (
         "penetrationTol:Inherited", "how much penetration is allowed",
         defaultPenetrationTol);
      myProps.addInheritable (
         "compliance:Inherited", "compliance for each contact constraint",
         defaultCompliance);
      myProps.addInheritable (
         "damping:Inherited", "damping for each contact constraint",
         defaultDamping);
      myProps.addInheritable (
         "acceleration:Inherited",
         "acceleration used to compute collision compliance from penetrationTol",
         defaultAcceleration);
      myProps.addInheritable (
         "rigidRegionTol:Inherited",
         "region size tolerance for creating contact planes",
         defaultRigidRegionTol);
      myProps.addInheritable (
         "rigidPointTol:Inherited", "point tolerance for creating contact planes",
         defaultRigidPointTol);
      myProps.addInheritable (
         "reduceConstraints:Inherited", "try to reduce the number of constraints",
         defaultReduceConstraints);
      myProps.addInheritable (
         "bodyFaceContact:Inherited",
         "add contacts for interpenetrating rigid body vertices",
         defaultBodyFaceContact);
      myProps.addInheritable (
         "drawIntersectionContours:Inherited", "draw mesh intersection contours",
         defaultDrawIntersectionContours);
      myProps.addInheritable (
         "drawIntersectionFaces:Inherited", "draw mesh intersection faces",
         defaultDrawIntersectionFaces);
      myProps.addInheritable (
         "drawIntersectionPoints:Inherited", "draw mesh intersection points",
         defaultDrawIntersectionPoints);
      myProps.addInheritable (
         "drawContactNormals:Inherited", "draw normals at each contact point",
         defaultDrawContactNormals);
      myProps.addInheritable (
         "drawContactForces:Inherited", "draw forces at each contact point",
         defaultDrawContactForces);
      myProps.addInheritable (
         "drawConstraints:Inherited", "draw contact constraints",
         defaultDrawConstraints);
      myProps.addInheritable (
         "drawColorMap:Inherited", 
         "draw a color map of the specified data",
         defaultDrawColorMap);
      myProps.addInheritable (
         "colorMapCollidable:Inherited", 
         "number of the collidable (0 or 1) on which the color map show be drawn",
         defaultColorMapCollidableNum, "[0,1] NoSlider");
      myProps.add (
         "colorMapRange", "range for drawing color maps", 
         defaultColorMapRange);
      myProps.addInheritable (
         "colorMapInterpolation",
         "explicit setting for how to interpolate color map (RGB or HSV)",
         defaultColorMapInterpolation);
      
   }

   public PropertyList getAllPropertyInfo() {
      return myProps;
   }

   /** 
    * Creates a new CollisionBehavior with default values.
    */
   public CollisionBehavior() {
      setDefaultValues();
   }

   // /** 
   //  * Creates a new CollisionBehavior whose values are copied from
   //  * an existing one.
   //  * 
   //  * @param b behavior to copy
   //  */
   // public CollisionBehavior (CollisionBehavior b) {
   //    // FINISH
   //    set (b);
   // }

   /** 
    * Creates a new CollisionBehavior with a specified enabling
    * and friction.
    * 
    * @param enabled true if collisions are enabled
    * @param mu friction coefficient. If less than 0, the value 
    * will be inherited from ancestor components. 
    */
   public CollisionBehavior (boolean enabled, double mu) {
      setDefaultValues();
      setEnabled (enabled);
      if (enabled && mu >= 0) {
         setFriction (mu);
      }
   }

   public CollisionBehavior (CollisionBehavior behav) {
      set (behav);
   }
   
   /** 
    * Returns true if collisions are enabled in this behavior.
    * 
    * @return true if collisions are enabled
    */
   public boolean isEnabled() {
      return myEnabled;
   }

   /** 
    * Enables or disabled collisions for this behavior.
    * 
    * @param enabled if true, enables collisions
    */
   public void setEnabled (boolean enabled) {
      myEnabled = enabled;
   }

   /** 
    * Gets the Coulomb friction coefficent associated with this behavior.
    * 
    * @return friction coefficent
    */
   public double getFriction() {
      return myFriction;
   }

   /** 
    * Sets the Coulomb friction coefficent associated with this behavior.
    * 
    * @param mu friction coefficent
    */
   public void setFriction (double mu) {
      myFriction = mu;
      myFrictionMode =
         PropertyUtils.propagateValue (
            this, "friction", myFriction, myFrictionMode);      
   }

   public void setFrictionMode (PropertyMode mode) {
      myFrictionMode =
         PropertyUtils.setModeAndUpdate (this, "friction", myFrictionMode, mode);
   }

   public PropertyMode getFrictionMode() {
      return myFrictionMode;
   }

   /** 
    * Returns the collision method to be used by this behavior.
    * 
    * @return collision method for this behavior
    */
   public Method getMethod() {
      return myMethod;
   }

   /** 
    * Set the collision method to be used by this behavior.
    * 
    * @param method collision method to be used
    */
   public void setMethod (Method method) {
      myMethod = method;
      myMethodMode =
         PropertyUtils.propagateValue (
            this, "method", myMethod, myMethodMode);      
   }

   public void setMethodMode (PropertyMode mode) {
      myMethodMode =
         PropertyUtils.setModeAndUpdate (this, "method", myMethodMode, mode);
   }

   public PropertyMode getMethodMode() {
      return myMethodMode;
   }

   /** 
    * Returns whether bilateral constraints should be used for vertex-based
    * contact.
    * 
    * @return {@code true} if bilateral constraints should be used
    */
   public boolean getBilateralVertexContact() {
      return myBilateralVertexContact;
   }

   /** 
    * Set whether bilateral constraints should be used for vertex-based
    * contact.
    * 
    * @param enable if {@code true}, enables bilateral constraints
    */
   public void setBilateralVertexContact (boolean enable) {
      myBilateralVertexContact = enable;
      myBilateralVertexContactMode =
         PropertyUtils.propagateValue (
            this, "bilateralVertexContact",
            myBilateralVertexContact, myBilateralVertexContactMode);
   }

   public void setBilateralVertexContactMode (PropertyMode mode) {
      myBilateralVertexContactMode =
         PropertyUtils.setModeAndUpdate (
            this, "bilateralVertexContact",
            myBilateralVertexContactMode, mode);
   }

   public PropertyMode getBilateralVertexContactMode() {
      return myBilateralVertexContactMode;
   }

   /** 
    * Returns the collider type to be used for determining collisions.
    * 
    * @return collider type for this behavior
    */
   public ColliderType getColliderType() {
      return myColliderType;
   }

   /** 
    * Set the collider type to be used for determining collisions.
    * 
    * @param ctype new collider type for this behavior
    */
   public void setColliderType (ColliderType ctype) {
      myColliderType = ctype;
      myColliderTypeMode =
         PropertyUtils.propagateValue (
            this, "colliderType", myColliderType, myColliderTypeMode);      
      // changing the collider type will invalidate previous state information
      notifyParentOfChange (new DynamicActivityChangeEvent (this));
   }

   public void setColliderTypeMode (PropertyMode mode) {
      ColliderType prev = myColliderType;
      myColliderTypeMode =
         PropertyUtils.setModeAndUpdate (
            this, "colliderType", myColliderTypeMode, mode);
      if (myColliderType != prev) {
         // changing the collider type will invalidate previous state information
         notifyParentOfChange (new DynamicActivityChangeEvent (this));
      }
   }

   public PropertyMode getColliderTypeMode() {
      return myColliderTypeMode;
   }

   /** 
    * Gets the penetration tolerance associated with this behavior.
    * 
    * @return penetration tolerance associated with this behavior
    */
   public double getPenetrationTol() {
      return myPenetrationTol;
   }

   /** 
    * Sets the penetration tolerance associated with this behavior.
    * 
    * @param tol new penetration tolerance
    */
   public void setPenetrationTol (double tol) {
      myPenetrationTol = tol;
      myPenetrationTolMode =
         PropertyUtils.propagateValue (
            this, "penetrationTol", myPenetrationTol, myPenetrationTolMode);      
   }

   public void setPenetrationTolMode (PropertyMode mode) {
      myPenetrationTolMode =
         PropertyUtils.setModeAndUpdate (
            this, "penetrationTol", myPenetrationTolMode, mode);
   }

   public PropertyMode getPenetrationTolMode() {
      return myPenetrationTolMode;
   }

   /** 
    * Gets the contact compliance associated with this behavior.
    * 
    * @return contact compliance
    */
   public double getCompliance() {
      return myCompliance;
   }

   /** 
    * Sets the contact compliance associated with this behavior.
    * 
    * @param c new contact compliance
    */
   public void setCompliance (double c) {
      myCompliance = c;
      myComplianceMode =
         PropertyUtils.propagateValue (
            this, "compliance", myCompliance, myComplianceMode);      
   }

   public void setComplianceMode (PropertyMode mode) {
      myComplianceMode =
         PropertyUtils.setModeAndUpdate (
            this, "compliance", myComplianceMode, mode);
   }

   public PropertyMode getComplianceMode() {
      return myComplianceMode;
   }

   /** 
    * Gets the contact damping associated with this behavior.
    * 
    * @return contact damping
    */
   public double getDamping() {
      return myDamping;
   }

   /** 
    * Sets the contact damping associated with this behavior.
    * 
    * @param d new contact damping
    */
   public void setDamping (double d) {
      myDamping = d;
      myDampingMode =
         PropertyUtils.propagateValue (
            this, "damping", myDamping, myDampingMode);      
   }

   public void setDampingMode (PropertyMode mode) {
      myDampingMode =
         PropertyUtils.setModeAndUpdate (this, "damping", myDampingMode, mode);
   }

   public PropertyMode getDampingMode() {
      return myDampingMode;
   }

   /**
    * Returns the desired collision acceleration. See {@link #setAcceleration}.
    */
   public double getAcceleration() {
      return myAcceleration;
   }

   /**
    * Sets a desired acceleration for collision response which will be used to
    * automatically compute collision compliance if the specified compliance
    * (as returned by {@link #getCompliance}) is zero.
    *
    * <p>This property is currently experimental and not guaranteed to produce
    * reliable results.
    *
    * @param acc desired collision acceleration
    */
   public void setAcceleration (double acc) {
      myAcceleration = acc;
      myAccelerationMode =
      PropertyUtils.propagateValue (
         this, "acceleration", myAcceleration, myAccelerationMode);        
   }

   public void setAccelerationMode (PropertyMode mode) {
      myAccelerationMode =
         PropertyUtils.setModeAndUpdate (
            this, "acceleration", myAccelerationMode, mode);
   }

   public PropertyMode getAccelerationMode() {
      return myAccelerationMode;
   }

   /** 
    * Gets the rigid region tolerance associated with this behavior.
    * 
    * @return rigid region tolerance
    */
   public double getRigidRegionTol() {
      return myRigidRegionTol;
   }

   /** 
    * Sets the rigid region tolerance associated with this behavior.
    * 
    * @param tol new rigid region tolerance
    */
   public void setRigidRegionTol (double tol) {
      myRigidRegionTol = tol;
      myRigidRegionTolMode =
         PropertyUtils.propagateValue (
            this, "rigidRegionTol", myRigidRegionTol, myRigidRegionTolMode);      
   }

   public void setRigidRegionTolMode (PropertyMode mode) {
      myRigidRegionTolMode =
         PropertyUtils.setModeAndUpdate (
            this, "rigidRegionTol", myRigidRegionTolMode, mode);
   }

   public PropertyMode getRigidRegionTolMode() {
      return myRigidRegionTolMode;
   }

   /** 
    * Gets the rigid point tolerance associated with this behavior.  This is
    * the point clustering distance used when computing contact planes.
    * 
    * @return rigid point tolerance
    */
   public double getRigidPointTol() {
      return myRigidPointTol;
   }

   /** 
    * Sets the rigid point tolerance associated with this behavior.
    * 
    * @param tol new rigid point tolerance
    */
   public void setRigidPointTol (double tol) {
      myRigidPointTol = tol;
      myRigidPointTolMode =
         PropertyUtils.propagateValue (
            this, "rigidPointTol", myRigidPointTol, myRigidPointTolMode);      
   }

   public void setRigidPointTolMode (PropertyMode mode) {
      myRigidPointTolMode =
         PropertyUtils.setModeAndUpdate (
            this, "rigidPointTol", myRigidPointTolMode, mode);
   }

   public PropertyMode getRigidPointTolMode() {
      return myRigidPointTolMode;
   }

   public void setForceBehavior (ContactForceBehavior behavior) {
      try {
         myForceBehavior = (ContactForceBehavior)behavior.clone();
      }
      catch (CloneNotSupportedException e) {
         throw new InternalErrorException (
            "Behavior " + behavior.getClass() + " does not support clone()");
      }
   }
   
   public ContactForceBehavior getForceBehavior() {
      return myForceBehavior;
   }

   /** 
    * Queries whether constraint reduction is enabled for this behavior.
    * 
    * @return true if constraint reduction is enabled
    */
   public boolean getReduceConstraints() {
      return myReduceConstraints;
   }

   /** 
    * Sets whether or not constraint reduction is enabled for this behavior.
    * 
    * @param enable true if constraint reduction should be enabled
    */
   public void setReduceConstraints (boolean enable) {
      myReduceConstraints = enable;
   }

   public void setReduceConstraintsMode (PropertyMode mode) {
      myReduceConstraintsMode =
         PropertyUtils.setModeAndUpdate (
            this, "reduceConstraints", myReduceConstraintsMode, mode);
   }

   public PropertyMode getReduceConstraintsMode() {
      return myReduceConstraintsMode;
   }

   /** 
    * Queries whether body face contact is enabled. See {@link
    * #setBodyFaceContact} for details.
    * 
    * @return true if body face face is enabled
    */
   public boolean getBodyFaceContact() {
      return myBodyFaceContact;
   }

   /** 
    * Enables or disables body face contact. If enabled, this means that for
    * rigid-deformable contact, contacts are also computed based on the rigid
    * body vertices that are penetrating the deformable body. The default value
    * for this property is <code>false</code>, since such contacts can result
    * in an overconstrained system.
    * 
    * @param enable true if body face contact should be enabled
    */
   public void setBodyFaceContact (boolean enable) {
      myBodyFaceContact = enable;
      myBodyFaceContactMode =
         PropertyUtils.propagateValue (
            this, "bodyFaceContact", myBodyFaceContact, myBodyFaceContactMode);
   }

   public void setBodyFaceContactMode (PropertyMode mode) {
      myBodyFaceContactMode =
         PropertyUtils.setModeAndUpdate (
            this, "bodyFaceContact", myBodyFaceContactMode, mode);
   }

   public PropertyMode getBodyFaceContactMode() {
      return myBodyFaceContactMode;
   }

   public boolean getDrawIntersectionContours() {
      return myDrawIntersectionContours;
   }

   public void setDrawIntersectionContours (boolean enable) {
      myDrawIntersectionContours = enable;
      myDrawIntersectionContoursMode =
         PropertyUtils.propagateValue (
            this, "drawIntersectionContours",
            myDrawIntersectionContours, myDrawIntersectionContoursMode);      
   }

   public void setDrawIntersectionContoursMode (PropertyMode mode) {
      myDrawIntersectionContoursMode =
         PropertyUtils.setModeAndUpdate (
            this, "drawIntersectionContours",
            myDrawIntersectionContoursMode, mode);
   }

   public PropertyMode getDrawIntersectionContoursMode() {
      return myDrawIntersectionContoursMode;
   }

   public boolean getDrawIntersectionFaces() {
      return myDrawIntersectionFaces;
   }

   public void setDrawIntersectionFaces (boolean enable) {
      myDrawIntersectionFaces = enable;
      myDrawIntersectionFacesMode =
         PropertyUtils.propagateValue (
            this, "drawIntersectionFaces",
            myDrawIntersectionFaces, myDrawIntersectionFacesMode);      
   }

   public void setDrawIntersectionFacesMode (PropertyMode mode) {
      myDrawIntersectionFacesMode =
         PropertyUtils.setModeAndUpdate (
            this, "drawIntersectionFaces", myDrawIntersectionFacesMode, mode);
   }

   public PropertyMode getDrawIntersectionFacesMode() {
      return myDrawIntersectionFacesMode;
   }

   public boolean getDrawIntersectionPoints() {
      return myDrawIntersectionPoints;
   }

   public void setDrawIntersectionPoints (boolean enable) {
      myDrawIntersectionPoints = enable;
      myDrawIntersectionPointsMode =
         PropertyUtils.propagateValue (
            this, "drawIntersectionPoints",
            myDrawIntersectionPoints, myDrawIntersectionPointsMode);      
   }

   public void setDrawIntersectionPointsMode (PropertyMode mode) {
      myDrawIntersectionPointsMode =
         PropertyUtils.setModeAndUpdate (
            this, "drawIntersectionPoints", myDrawIntersectionPointsMode, mode);
   }

   public PropertyMode getDrawIntersectionPointsMode() {
      return myDrawIntersectionPointsMode;
   }

   public boolean getDrawContactNormals() {
      return myDrawContactNormals;
   }

   public void setDrawContactNormals (boolean enable) {
      myDrawContactNormals = enable;
      myDrawContactNormalsMode =
         PropertyUtils.propagateValue (
            this, "drawContactNormals",
            myDrawContactNormals, myDrawContactNormalsMode);
   }

   public void setDrawContactNormalsMode (PropertyMode mode) {
      myDrawContactNormalsMode =
         PropertyUtils.setModeAndUpdate (
            this, "drawContactNormals", myDrawContactNormalsMode, mode);
   }

   public PropertyMode getDrawContactNormalsMode() {
      return myDrawContactNormalsMode;
   }

   public boolean getDrawContactForces() {
      return myDrawContactForces;
   }

   public void setDrawContactForces (boolean enable) {
      myDrawContactForces = enable;
      myDrawContactForcesMode =
         PropertyUtils.propagateValue (
            this, "drawContactForces",
            myDrawContactForces, myDrawContactForcesMode);
   }

   public void setDrawContactForcesMode (PropertyMode mode) {
      myDrawContactForcesMode =
         PropertyUtils.setModeAndUpdate (
            this, "drawContactForces", myDrawContactForcesMode, mode);
   }

   public PropertyMode getDrawContactForcesMode() {
      return myDrawContactForcesMode;
   }

   public boolean getDrawConstraints() {
      return myDrawConstraints;
   }

   public void setDrawConstraints (boolean enable) {
      myDrawConstraints = enable;
      myDrawConstraintsMode =
         PropertyUtils.propagateValue (
            this, "drawConstraints", myDrawConstraints, myDrawConstraintsMode);
   }

   public void setDrawConstraintsMode (PropertyMode mode) {
      myDrawConstraintsMode =
         PropertyUtils.setModeAndUpdate (
            this, "drawConstraints", myDrawConstraintsMode, mode);
   }

   public PropertyMode getDrawConstraintsMode() {
      return myDrawConstraintsMode;
   }

   /**
    * @deprecated
    * Replaced by getColorMapCollidable()
    */
   public int getDrawPenetrationDepth() {
      if (getDrawColorMap() == ColorMapType.PENETRATION_DEPTH) {
         return getColorMapCollidable();
      }
      else {
         return -1;
      }
   }

   /**
    * @deprecated
    * Replaced by the combination of
    * {@link #setDrawColorMap} and {@link setColorMapCollidable}.
    */
   public void setDrawPenetrationDepth (int colNum) {
      if (colNum == -1) {
         setDrawColorMap (ColorMapType.NONE);
      }
      else {
         setDrawColorMap (ColorMapType.PENETRATION_DEPTH);
         setColorMapCollidable (colNum);
      }
   }

   public void setPenetrationDepthRange (ScalarRange range) {
      setColorMapRange (range);
   }
   
   public ScalarRange getPenetrationDepthRange() {
      return getColorMapRange();
   }

   public void setColorMapRange (ScalarRange range) {
      ScalarRange newRange = range.clone();
      PropertyUtils.updateCompositeProperty (
            this, "colorMapRange", myColorMapRange, newRange);
      myColorMapRange = newRange;
   }
   
   public ScalarRange getColorMapRange() {
      return myColorMapRange;
   }

   public void setColorMapInterpolation (ColorInterpolation interp) {
      myColorMapInterpolation = interp;
      myColorMapInterpolationMode =
         PropertyUtils.propagateValue (
            this, "colorMapInterpolation",
            myColorMapInterpolation, myColorMapInterpolationMode);
   }
   
   public ColorInterpolation getColorMapInterpolation() {
      return myColorMapInterpolation;
   }

   public void setColorMapInterpolationMode (PropertyMode mode) {
      myColorMapInterpolationMode =
         PropertyUtils.setModeAndUpdate (
            this, "colorMapInterpolation", myColorMapInterpolationMode, mode);
   }

   public PropertyMode getColorMapInterpolationMode() {
      return myColorMapInterpolationMode;
   }

   public ColorMapType getDrawColorMap() {
      return myDrawColorMap;
   }

   public void setDrawColorMap (ColorMapType type) {
      myDrawColorMap = type;
      myDrawColorMapMode =
         PropertyUtils.propagateValue (
            this, "drawColorMap",
            myDrawColorMap, myDrawColorMapMode);
   }

   public void setDrawColorMapMode (PropertyMode mode) {
      myDrawColorMapMode =
         PropertyUtils.setModeAndUpdate (
            this, "drawColorMap", myDrawColorMapMode, mode);
   }

   public PropertyMode getDrawColorMapMode() {
      return myDrawColorMapMode;
   }

   public int getColorMapCollidable() {
      return myColorMapCollidableNum;
   }

   public void setColorMapCollidable (int colNum) {
      if (colNum != 0 && colNum != 1) {
         throw new InternalErrorException ("colNum must be 0 or 1");
      }
      myColorMapCollidableNum = colNum;
      myColorMapCollidableMode =
         PropertyUtils.propagateValue (
            this, "colorMapCollidable",
            myColorMapCollidableNum, myColorMapCollidableMode);
   }

   public void setColorMapCollidableMode (PropertyMode mode) {
      myColorMapCollidableMode =
         PropertyUtils.setModeAndUpdate (
            this, "colorMapCollidable", myColorMapCollidableMode, mode);
   }

   public PropertyMode getColorMapCollidableMode() {
      return myColorMapCollidableMode;
   }

   public boolean isCompliant() {
      return (myCompliance != 0 || myForceBehavior != null);
   }

   protected boolean scanItem (ReaderTokenizer rtok, Deque<ScanToken> tokens)
      throws IOException {

      rtok.nextToken();
      if (scanAttributeName (rtok, "forceBehavior")) {
         myForceBehavior =
            (ContactForceBehavior)Scan.scanClassAndObject (rtok, null);
         return true;
      }
      rtok.pushBack();
      return super.scanItem (rtok, tokens);
   }

   protected void writeItems (
      PrintWriter pw, NumberFormat fmt, CompositeComponent ancestor)
      throws IOException {

      if (myForceBehavior instanceof Scannable) {
         pw.print ("forceBehavior="+myForceBehavior.getClass().getName());
         ((Scannable)myForceBehavior).write (pw, fmt, ancestor);
      }    
      super.writeItems (pw, fmt, ancestor); 
   }

   public void set (CollisionBehavior behav) {
      if (behav == this) {
         return;
      }
      myEnabled = behav.myEnabled;
      myFriction = behav.myFriction;
      myFrictionMode = behav.myFrictionMode;
      myMethod = behav.myMethod;
      myMethodMode = behav.myMethodMode;
      myBilateralVertexContact = behav.myBilateralVertexContact;
      myBilateralVertexContactMode = behav.myBilateralVertexContactMode;
      myPenetrationTol = behav.myPenetrationTol;
      myPenetrationTolMode = behav.myPenetrationTolMode;
      myCompliance = behav.myCompliance;
      myComplianceMode = behav.myComplianceMode;
      myDamping = behav.myDamping;
      myDampingMode = behav.myDampingMode;
      myAcceleration = behav.myAcceleration;
      myAccelerationMode = behav.myAccelerationMode;
      myRigidRegionTol = behav.myRigidRegionTol;
      myRigidRegionTolMode = behav.myRigidRegionTolMode;
      myRigidPointTol = behav.myRigidPointTol;
      myRigidPointTolMode = behav.myRigidPointTolMode;
      myReduceConstraints = behav.myReduceConstraints;
      myReduceConstraintsMode = behav.myReduceConstraintsMode;
      myDrawIntersectionContours = behav.myDrawIntersectionContours;
      myDrawIntersectionContoursMode = behav.myDrawIntersectionContoursMode;
      myDrawIntersectionFaces = behav.myDrawIntersectionFaces;
      myDrawIntersectionFacesMode = behav.myDrawIntersectionFacesMode;
      myDrawIntersectionPoints = behav.myDrawIntersectionPoints;
      myDrawIntersectionPointsMode = behav.myDrawIntersectionPointsMode;
      myDrawConstraints = behav.myDrawConstraints;
      myDrawConstraintsMode = behav.myDrawConstraintsMode;
      myDrawColorMap = behav.myDrawColorMap;
      myDrawColorMapMode = behav.myDrawColorMapMode;
      myColorMapCollidableNum = behav.myColorMapCollidableNum;
      myColorMapCollidableMode = behav.myColorMapCollidableMode;
      myForceBehavior = behav.myForceBehavior; // XXX should we copy?
      setRenderProps (behav.myRenderProps);
   }

   /** 
    * Returns true if this behavior equals another. The values
    * returned by {@link #getPair getPair}
    * are not considered in this comparision.
    *
    * <p>This method is mainly used for testing purposes
    * 
    * @param behav behavior to compare with
    * @return true if this behavior equals behav
    */
   boolean equals (CollisionBehavior behav) {
      PropertyMode EXPLICIT = PropertyMode.Explicit;
      if (myEnabled != behav.myEnabled) {
         return false;
      }
      if (myFrictionMode != behav.myFrictionMode) {
         return false;
      }
      else if (myFrictionMode == EXPLICIT &&
               myFriction != behav.myFriction) {
         return false;
      }
      if (myMethodMode != behav.myMethodMode) {
         return false;
      }
      else if (myMethodMode == EXPLICIT &&
               myMethod != behav.myMethod) {
         return false;
      }
      if (myBilateralVertexContactMode != behav.myBilateralVertexContactMode) {
         return false;
      }
      else if (myBilateralVertexContactMode == EXPLICIT &&
               myBilateralVertexContact != behav.myBilateralVertexContact) {
         return false;
      }
      if (myPenetrationTolMode != behav.myPenetrationTolMode) {
         return false;
      }
      else if (myPenetrationTolMode == EXPLICIT &&
               myPenetrationTol != behav.myPenetrationTol) {
         return false;
      }
      if (myComplianceMode != behav.myComplianceMode) {
         return false;
      }
      else if (myComplianceMode == EXPLICIT &&
               myCompliance != behav.myCompliance) {
         return false;
      }
      if (myDampingMode != behav.myDampingMode) {
         return false;
      }
      else if (myDampingMode == EXPLICIT &&
               myDamping != behav.myDamping) {
         return false;
      }
      if (myAccelerationMode != behav.myAccelerationMode) {
         return false;
      }
      else if (myAccelerationMode == EXPLICIT &&
               myAcceleration != behav.myAcceleration) {
         return false;
      }
      if (myRigidRegionTolMode != behav.myRigidRegionTolMode) {
         return false;
      }
      else if (myRigidRegionTolMode == EXPLICIT &&
               myRigidRegionTol != behav.myRigidRegionTol) {
         return false;
      }
      if (myRigidPointTolMode != behav.myRigidPointTolMode) {
         return false;
      }
      else if (myRigidPointTolMode == EXPLICIT &&
               myRigidPointTol != behav.myRigidPointTol) {
         return false;
      }
      if (myReduceConstraintsMode != behav.myReduceConstraintsMode) {
         return false;
      }
      else if (myReduceConstraintsMode == EXPLICIT &&
               myReduceConstraints != behav.myReduceConstraints) {
         return false;
      }
      if (myDrawIntersectionContoursMode!=behav.myDrawIntersectionContoursMode) {
         return false;
      }
      else if (myDrawIntersectionContoursMode == EXPLICIT &&
               myDrawIntersectionContours != behav.myDrawIntersectionContours) {
         return false;
      }
      if (myDrawIntersectionFacesMode != behav.myDrawIntersectionFacesMode) {
         return false;
      }
      else if (myDrawIntersectionFacesMode == EXPLICIT &&
               myDrawIntersectionFaces != behav.myDrawIntersectionFaces) {
         return false;
      }
      if (myDrawIntersectionPointsMode != behav.myDrawIntersectionPointsMode) {
         return false;
      }
      else if (myDrawIntersectionPointsMode == EXPLICIT &&
               myDrawIntersectionPoints != behav.myDrawIntersectionPoints) {
         return false;
      }
      if (myDrawConstraintsMode != behav.myDrawConstraintsMode) {
         return false;
      }
      else if (myDrawConstraintsMode == EXPLICIT &&
               myDrawConstraints != behav.myDrawConstraints) {
         return false;
      }
      if (myDrawColorMapMode != behav.myDrawColorMapMode) {
         return false;
      }
      else if (myDrawColorMapMode == EXPLICIT &&
               myDrawColorMap != behav.myDrawColorMap) {
         return false;
      }
      if (myColorMapCollidableMode != behav.myColorMapCollidableMode) {
         return false;
      }
      else if (myColorMapCollidableMode == EXPLICIT &&
               myColorMapCollidableNum != behav.myColorMapCollidableNum) {
         return false;
      }
      if ((myForceBehavior==null) != (behav.myForceBehavior==null)) {
         return false;
      }
      else if (myForceBehavior != null) {
         return myForceBehavior.equals (behav.myForceBehavior);
      }
      if (!RenderProps.equals (myRenderProps, behav.myRenderProps)) {
         return false;
      }
      return true;
   }

   // --- begin Renderable interface ---

   public RenderProps getRenderProps() {
      return myRenderProps;
   }

   public void setRenderProps (RenderProps props) {
      myRenderProps =
         RenderableComponentBase.updateRenderProps (this, myRenderProps, props);
   }

   public void prerender (RenderList list) {
   }

   /**
    * Render method for this component is just a stub - it is needed because
    * this class extends RenderableComponentBase, which is done to export the
    * fact that the class has render properties, and also exports them as a
    * property.
    */
   public void render (Renderer renderer, int flags) {
   }

   public void updateBounds (Vector3d pmin, Vector3d pmax) {
   }

   public void getSelection (LinkedList<Object> list, int qid) {
   }
   
   public RenderProps createRenderProps() {
      return RenderProps.createRenderProps (this);
   }

   public int getRenderHints() {
      int code = 0;
      if (myRenderProps != null && myRenderProps.isTransparent()) {
         code |= TRANSPARENT;
      }
      return code;
   }

   /**
    * {@inheritDoc}
    */
   public boolean isSelectable() {
      return true;
   }

   public int numSelectionQueriesNeeded() {
      return -1;
   }

   // ---- end Renderable interface ----

   public void scaleDistance (double s) {
      if (myRigidPointTol != -1) {
         myRigidPointTol *= s;
      }
      if (myRigidRegionTol != -1) {
         myRigidRegionTol *= s;
      }
      myAcceleration *= s;
      myColorMapRange.scale (s);
      if (myRenderProps != null) {
         myRenderProps.scaleDistance (s);
      }
   }

   public void scaleMass (double s) {
      myCompliance /= s;
      myDamping *= s;
   }   

//   /** 
//    * Returns the MechModel responsible for determining this behavior. This
//    * information is not normally set by the application.
//    * 
//    * @return MechModel associated with this behavior
//    */
//   public MechModel getModel() {
//      return myModel;
//   }

//   /** 
//    * Returns the collision pair associated with this behavior. This
//    * information is not normally set by the application.
//    * 
//    * @return collision pair associated with this behavior.
//    */
//   public CollidablePair getPair() {
//      return myPair;
//   }
   
}
