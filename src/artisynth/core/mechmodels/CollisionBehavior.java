/**
 * Copyright (c) 2014, by the Authors: John E Lloyd (UBC)
 *
 * This software is freely available under a 2-clause BSD license. Please see
 * the LICENSE file in the ArtiSynth distribution directory for details.
 */
package artisynth.core.mechmodels;

import java.io.*;
import java.util.Deque;
import java.util.LinkedList;

import maspack.util.*;
import maspack.matrix.*;
import maspack.render.*;
import maspack.render.Renderer.ColorInterpolation;
import maspack.properties.*;
import artisynth.core.util.*;
import artisynth.core.modelbase.*;
import artisynth.core.materials.*;
import artisynth.core.mechmodels.CollisionManager.ColliderType;

/**
 * Contains information describing the appropriate collision response
 * between two bodies.
 */
public class CollisionBehavior extends CollisionComponent
   implements Renderable {

   /**
    * Specifies the <i>contact method</i> defining how the constraints are
    * generated for handling collisions.
    */
   public enum Method {
      /**
       * Select the method most appropriate depending on whether
       * the colliding bodies are rigid or deformable.
       */
      DEFAULT,
      
      /**
       * A contact constraint is generated for each mesh vertex that
       * interpenetrates the other mesh, with the normal direction
       * determined by finding the nearest point on the opposing
       * mesh.  This method is the default for collisions involving deformable
       * bodies, and assumes that the bodies have sufficient degrees of freedom
       * (DOF) that the system is not overly constrained. Using this method for
       * collisions between rigid bodies, or low DOF deformable bodies, will
       * generally result in an overconstrained system unless the constraints
       * are either regularized using compliance (see {@link #setCompliance})
       * or constraint reduction is enabled (see {@link #setReduceConstraints}).
       */
      VERTEX_PENETRATION,
      
      /**
       * Contact constraints are generated in the same way as for {@link
       * #VERTEX_PENETRATION}, with additional constraints created for edge-edge
       * contacts. This can be useful in situations where one or both of the
       * colliding meshes are coarse and penetrating vertices may hence not
       * always be present. However, this method is experimental and not used
       * by default.
       */
      VERTEX_EDGE_PENETRATION,
      
      /**
       * Contact constraints are generated by fitting a plane to each mesh
       * penetration region and then projecting the region onto that plane.
       * Constraints are then created from points on the perimeter of this
       * projection, with the normal direction being given by the plane
       * normal. This is the default method for collision between rigid bodies
       * or low DOF deformable bodies. Trying to use this method for FEM-based
       * deformable bodies will result in an error.
       */
      CONTOUR_REGION,
      
      /**
       * Currently the same as {@link #VERTEX_PENETRATION}.
       */
      VERTEX_PENETRATION_BILATERAL,
      
      /**
       * No constraints are generated. This setting will result in
       * no collision response.
       */
      INACTIVE
   }
   
   /**
    * Indicates when two-way contact is used for the {@link
    * Method#VERTEX_PENETRATION} or {@link Method#VERTEX_EDGE_PENETRATION}
    * contact methods.
    *
    * For the @link Method#VERTEX_PENETRATION} or {@link
    * Method#VERTEX_EDGE_PENETRATION} contact methods, indicates whether
    * vertex penetrations are calculated for the first collidable,
    * the second collidable, or both.
    */
   public enum VertexPenetrations {
      /**
       * Vertex penetrations are calculated for <i>both</i> collidables.
       */
      BOTH_COLLIDABLES,

      /**
       * Vertex penetrations are calculated for the first collidable.
       */
      FIRST_COLLIDABLE,

      /**
       * Vertex penetrations are calculated for the second collidable.
       */
      SECOND_COLLIDABLE,

      /**
       * Vertex penetrations are determined automatically as follows:
       *
       * <ol>
       *
       * <li> If <i>neither</i> collidable corresponds to a rigid body,
       * penetrations are calculated for <i>both</i> collidables.
       * 
       * <li> If <i>one</i> collidable corresponds to a rigid body,
       * penetrations are calculated for the <i>non-rigid</i> collidable.
       *
       * <li> If <i>both</i> collidables correspond to a rigid body,
       * penetrations are calculated for the <i>first</i> collidable indicated
       * by the collision behavior.
       *
       * </ol> 
       */
      AUTO
   }

   /**
    * Specified what type of data should be used when drawing a color
    * map over the collision area.
    */
   public enum ColorMapType {
      /**
       * No color map should be drawn.
       */
      NONE,

      /**
       * Draw a color map of the penetration depth.
       */
      PENETRATION_DEPTH,

      /**
       * Draw a color map of the contact pressure. This is usually most useful
       * and accurate when used in conjunction with vertex penetration
       * collisions (see {@link CollisionBehavior.Method}).
       */
      CONTACT_PRESSURE
   }

   protected RenderProps myRenderProps;

   boolean myEnabled = false;

   static double defaultFriction = 0;
   double myFriction = defaultFriction;
   PropertyMode myFrictionMode = PropertyMode.Inherited;

   static Method defaultMethod = Method.DEFAULT;
   Method myMethod = defaultMethod;
   PropertyMode myMethodMode = PropertyMode.Inherited;

   static boolean defaultBilateralVertexContact = true;
   boolean myBilateralVertexContact = defaultBilateralVertexContact;
   PropertyMode myBilateralVertexContactMode = PropertyMode.Inherited;

   ColliderType myColliderType = CollisionManager.myDefaultColliderType;
   PropertyMode myColliderTypeMode = PropertyMode.Inherited;

//   MechModel myModel = null;

   static double defaultPenetrationTol = 0.001;
   double myPenetrationTol = defaultPenetrationTol;
   PropertyMode myPenetrationTolMode = PropertyMode.Inherited;

   static double defaultCompliance = 0.0;
   double myCompliance = defaultCompliance;
   PropertyMode myComplianceMode = PropertyMode.Inherited;

   static double defaultDamping = 0.0;
   double myDamping = defaultDamping;
   PropertyMode myDampingMode = PropertyMode.Inherited;

   static double defaultStictionCreep = 0.0;
   double myStictionCreep = defaultStictionCreep;
   PropertyMode myStictionCreepMode = PropertyMode.Inherited;

   static double defaultAcceleration = 0;
   double myAcceleration = defaultAcceleration;
   PropertyMode myAccelerationMode = PropertyMode.Inherited;

   static double defaultRigidRegionTol = 0.0;
   double myRigidRegionTol = defaultRigidRegionTol;
   PropertyMode myRigidRegionTolMode = PropertyMode.Inherited;

   static double defaultRigidPointTol = 0.0;
   double myRigidPointTol = defaultRigidPointTol;
   PropertyMode myRigidPointTolMode = PropertyMode.Inherited;

   static boolean defaultReduceConstraints = false;
   boolean myReduceConstraints = defaultReduceConstraints;
   PropertyMode myReduceConstraintsMode = PropertyMode.Inherited;

   static VertexPenetrations defaultVertexPenetrations = VertexPenetrations.AUTO;
   VertexPenetrations myVertexPenetrations = defaultVertexPenetrations;
   PropertyMode myVertexPenetrationsMode = PropertyMode.Inherited;

   static boolean defaultDrawIntersectionContours = false;
   boolean myDrawIntersectionContours = defaultDrawIntersectionContours;
   PropertyMode myDrawIntersectionContoursMode = PropertyMode.Inherited;

   static boolean defaultDrawIntersectionFaces = false;
   boolean myDrawIntersectionFaces = defaultDrawIntersectionFaces;
   PropertyMode myDrawIntersectionFacesMode = PropertyMode.Inherited;

   static boolean defaultDrawIntersectionPoints = false;
   boolean myDrawIntersectionPoints = defaultDrawIntersectionPoints;
   PropertyMode myDrawIntersectionPointsMode = PropertyMode.Inherited;

   static boolean defaultDrawContactNormals = false;
   boolean myDrawContactNormals = defaultDrawContactNormals;
   PropertyMode myDrawContactNormalsMode = PropertyMode.Inherited;

   static boolean defaultDrawContactForces = false;
   boolean myDrawContactForces = defaultDrawContactForces;
   PropertyMode myDrawContactForcesMode = PropertyMode.Inherited;

   static boolean defaultDrawFrictionForces = false;
   boolean myDrawFrictionForces = defaultDrawFrictionForces;
   PropertyMode myDrawFrictionForcesMode = PropertyMode.Inherited;

   // static boolean defaultDrawConstraints = false;
   // boolean myDrawConstraints = defaultDrawConstraints;
   // PropertyMode myDrawConstraintsMode = PropertyMode.Inherited;

   static ScalarRange defaultColorMapRange = null;
   ScalarRange myColorMapRange = null;

   static ColorInterpolation defaultColorMapInterpolation =
      ColorInterpolation.HSV;
   ColorInterpolation myColorMapInterpolation = defaultColorMapInterpolation;
   PropertyMode myColorMapInterpolationMode = PropertyMode.Inherited;

   static ColorMapType defaultDrawColorMap = ColorMapType.NONE;
   ColorMapType myDrawColorMap = defaultDrawColorMap;
   PropertyMode myDrawColorMapMode = PropertyMode.Inherited;

   static int defaultRenderingCollidableNum = 0;
   int myRenderingCollidableNum = defaultRenderingCollidableNum;
   PropertyMode myRenderingCollidableMode = PropertyMode.Inherited;

   ContactForceBehavior myForceBehavior = null;

   protected void setDefaultValues() {
      super.setDefaultValues();
      myEnabled = false;
      myFriction = defaultFriction;
      myFrictionMode = PropertyMode.Inherited;
      myMethod = defaultMethod;
      myMethodMode = PropertyMode.Inherited;
      myColliderType = CollisionManager.myDefaultColliderType;
      myColliderTypeMode = PropertyMode.Inherited;
      myBilateralVertexContact = defaultBilateralVertexContact;
      myBilateralVertexContactMode = PropertyMode.Inherited;
      myPenetrationTol = defaultPenetrationTol;
      myPenetrationTolMode = PropertyMode.Inherited;
      myCompliance = defaultCompliance;
      myComplianceMode = PropertyMode.Inherited;
      myDamping = defaultDamping;
      myDampingMode = PropertyMode.Inherited;
      myStictionCreep = defaultStictionCreep;
      myStictionCreepMode = PropertyMode.Inherited;
      myAcceleration = defaultAcceleration;
      myAccelerationMode = PropertyMode.Inherited;
      myRigidRegionTol = defaultRigidRegionTol;
      myRigidRegionTolMode = PropertyMode.Inherited;
      myRigidPointTol = defaultRigidPointTol;
      myRigidPointTolMode = PropertyMode.Inherited;
      myReduceConstraints = defaultReduceConstraints;
      myReduceConstraintsMode = PropertyMode.Inherited;
      myVertexPenetrations = defaultVertexPenetrations;
      myVertexPenetrationsMode = PropertyMode.Inherited;
      myDrawIntersectionContours = defaultDrawIntersectionContours;
      myDrawIntersectionContoursMode = PropertyMode.Inherited;
      myDrawIntersectionFaces = defaultDrawIntersectionFaces;
      myDrawIntersectionFacesMode = PropertyMode.Inherited;
      myDrawIntersectionPoints = defaultDrawIntersectionPoints;
      myDrawIntersectionPointsMode = PropertyMode.Inherited;
      myDrawContactNormals = defaultDrawContactNormals;
      myDrawContactNormalsMode = PropertyMode.Inherited;
      myDrawContactForces = defaultDrawContactForces;
      myDrawContactForcesMode = PropertyMode.Inherited;
      myDrawFrictionForces = defaultDrawFrictionForces;
      myDrawFrictionForcesMode = PropertyMode.Inherited;
      // myDrawConstraints = defaultDrawConstraints;
      // myDrawConstraintsMode = PropertyMode.Inherited;
      myDrawColorMap = defaultDrawColorMap;
      myDrawColorMapMode = PropertyMode.Inherited;
      myColorMapInterpolation = defaultColorMapInterpolation;
      myColorMapInterpolationMode = PropertyMode.Inherited;
      myRenderingCollidableNum = defaultRenderingCollidableNum;
      myRenderingCollidableMode = PropertyMode.Inherited;
      setColorMapRange (defaultColorMapRange);
      myForceBehavior = null;
   }

   public static PropertyList myProps =
      new PropertyList (CollisionBehavior.class, CollisionComponent.class);

   static {
      myProps.add ("renderProps", "renderer properties", null);
      myProps.add (
         "enabled isEnabled", "true if collisions are enabled", false);
      myProps.addInheritable (
         "friction:Inherited", "friction coefficient", defaultFriction);
      myProps.addInheritable (
         "method:Inherited", "collision handling method", defaultMethod);
      myProps.addInheritable (
         "vertexPenetrations:Inherited",
         "whether vertex penetrations are calculated for the first, second" +
         " or both collidables",
         defaultVertexPenetrations);
      myProps.addInheritable (
         "bilateralVertexContact:Inherited",
         "allow bilateral constraints for vertex-based contacts", 
         defaultBilateralVertexContact);
      myProps.addInheritable (
         "colliderType", "type of collider to use for collisions",
         CollisionManager.myDefaultColliderType);
      myProps.addInheritable (
         "reduceConstraints:Inherited", "try to reduce the number of constraints",
         defaultReduceConstraints);
      myProps.addInheritable (
         "compliance:Inherited", "compliance for each contact constraint",
         defaultCompliance);
      myProps.addInheritable (
         "damping:Inherited", "damping for each contact constraint",
         defaultDamping);
      myProps.addInheritable (
         "stictionCreep:Inherited", "stictionCreep for each contact constraint",
         defaultStictionCreep);
      myProps.add (
         "forceBehavior",
         "behavior for explicitly computing contact forces", null, "XE");
      myProps.addInheritable (
         "penetrationTol:Inherited", "how much penetration is allowed",
         defaultPenetrationTol);
      myProps.addInheritable (
         "rigidRegionTol:Inherited",
         "region size tolerance for creating contact planes",
         defaultRigidRegionTol);
      myProps.addInheritable (
         "rigidPointTol:Inherited", "point tolerance for creating contact planes",
         defaultRigidPointTol);
      myProps.addInheritable (
         "acceleration:Inherited",
         "acceleration used to compute collision compliance from penetrationTol",
         defaultAcceleration);

      myProps.addInheritable (
         "renderingCollidable:Inherited", 
         "collidable (0 or 1) for which normals, forces, color maps, etc. show be drawn",
         defaultRenderingCollidableNum, "[0,1] NoSlider");
      myProps.addInheritable (
         "drawIntersectionContours:Inherited", "draw mesh intersection contours",
         defaultDrawIntersectionContours);
      myProps.addInheritable (
         "drawIntersectionPoints:Inherited", "draw mesh intersection points",
         defaultDrawIntersectionPoints);
      myProps.addInheritable (
         "drawIntersectionFaces:Inherited", "draw mesh intersection faces",
         defaultDrawIntersectionFaces);
      myProps.addInheritable (
         "drawContactNormals:Inherited", "draw normals at each contact point",
         defaultDrawContactNormals);
      myProps.addInheritable (
         "drawContactForces:Inherited", "draw forces at each contact point",
         defaultDrawContactForces);
      myProps.addInheritable (
         "drawFrictionForces:Inherited",
         "draw friction orces at each contact point",
         defaultDrawFrictionForces);
      myProps.addInheritable (
         "drawColorMap:Inherited", 
         "draw a color map of the specified data",
         defaultDrawColorMap);
      myProps.add (
         "colorMapRange", "range for drawing color maps", 
         defaultColorMapRange);
      myProps.addInheritable (
         "colorMapInterpolation",
         "explicit setting for how to interpolate color map (RGB or HSV)",
         defaultColorMapInterpolation);
   }

   public PropertyList getAllPropertyInfo() {
      return myProps;
   }

   /** 
    * Creates a new CollisionBehavior with default values.
    */
   public CollisionBehavior() {
      setDefaultValues();
   }

   // /** 
   //  * Creates a new CollisionBehavior whose values are copied from
   //  * an existing one.
   //  * 
   //  * @param b behavior to copy
   //  */
   // public CollisionBehavior (CollisionBehavior b) {
   //    // FINISH
   //    set (b);
   // }

   /** 
    * Creates a new CollisionBehavior with a specified enabling
    * and friction.
    * 
    * @param enabled true if collisions are enabled
    * @param mu friction coefficient. If less than 0, the value 
    * will be inherited from ancestor components. 
    */
   public CollisionBehavior (boolean enabled, double mu) {
      setDefaultValues();
      setEnabled (enabled);
      if (enabled && mu >= 0) {
         setFriction (mu);
      }
   }

   public CollisionBehavior (CollisionBehavior behav) {
      set (behav);
   }
   
   /** 
    * Returns true if collisions are enabled in this behavior.
    * 
    * @return true if collisions are enabled
    */
   public boolean isEnabled() {
      return myEnabled;
   }

   /** 
    * Enables or disabled collisions for this behavior.
    * 
    * @param enabled if true, enables collisions
    */
   public void setEnabled (boolean enabled) {
      myEnabled = enabled;
   }

   /** 
    * Gets the Coulomb friction coefficient associated with this behavior.
    * 
    * @return friction coefficient
    */
   public double getFriction() {
      return myFriction;
   }

   /** 
    * Sets the Coulomb friction coefficient associated with this behavior.
    * 
    * @param mu friction coefficient
    */
   public void setFriction (double mu) {
      myFriction = mu;
      myFrictionMode =
         PropertyUtils.propagateValue (
            this, "friction", myFriction, myFrictionMode);      
   }

   public void setFrictionMode (PropertyMode mode) {
      myFrictionMode =
         PropertyUtils.setModeAndUpdate (this, "friction", myFrictionMode, mode);
   }

   public PropertyMode getFrictionMode() {
      return myFrictionMode;
   }

   /** 
    * Returns the contact method to be used by this behavior.
    * 
    * @return contact method for this behavior
    */
   public Method getMethod() {
      return myMethod;
   }

   /** 
    * Set the contact method to be used by this behavior.
    * 
    * @param method contact method to be used
    */
   public void setMethod (Method method) {
      myMethod = method;
      myMethodMode =
         PropertyUtils.propagateValue (
            this, "method", myMethod, myMethodMode);      
   }

   public void setMethodMode (PropertyMode mode) {
      myMethodMode =
         PropertyUtils.setModeAndUpdate (this, "method", myMethodMode, mode);
   }

   public PropertyMode getMethodMode() {
      return myMethodMode;
   }

   /** 
    * Returns whether bilateral constraints should be used for vertex-based
    * contact.
    * 
    * @return {@code true} if bilateral constraints should be used
    */
   public boolean getBilateralVertexContact() {
      return myBilateralVertexContact;
   }

   /** 
    * Set whether bilateral constraints should be used for vertex-based
    * contact.
    * 
    * @param enable if {@code true}, enables bilateral constraints
    */
   public void setBilateralVertexContact (boolean enable) {
      myBilateralVertexContact = enable;
      myBilateralVertexContactMode =
         PropertyUtils.propagateValue (
            this, "bilateralVertexContact",
            myBilateralVertexContact, myBilateralVertexContactMode);
   }

   public void setBilateralVertexContactMode (PropertyMode mode) {
      myBilateralVertexContactMode =
         PropertyUtils.setModeAndUpdate (
            this, "bilateralVertexContact",
            myBilateralVertexContactMode, mode);
   }

   public PropertyMode getBilateralVertexContactMode() {
      return myBilateralVertexContactMode;
   }

   /** 
    * Returns the collider type to be used for determining collisions.
    * 
    * @return collider type for this behavior
    */
   public ColliderType getColliderType() {
      return myColliderType;
   }

   /** 
    * Set the collider type to be used for determining collisions.
    * 
    * @param ctype new collider type for this behavior
    */
   public void setColliderType (ColliderType ctype) {
      myColliderType = ctype;
      myColliderTypeMode =
         PropertyUtils.propagateValue (
            this, "colliderType", myColliderType, myColliderTypeMode);      
      // changing the collider type will invalidate previous state information
      notifyParentOfChange (new DynamicActivityChangeEvent (this));
   }

   public void setColliderTypeMode (PropertyMode mode) {
      ColliderType prev = myColliderType;
      myColliderTypeMode =
         PropertyUtils.setModeAndUpdate (
            this, "colliderType", myColliderTypeMode, mode);
      if (myColliderType != prev) {
         // changing the collider type will invalidate previous state information
         notifyParentOfChange (new DynamicActivityChangeEvent (this));
      }
   }

   public PropertyMode getColliderTypeMode() {
      return myColliderTypeMode;
   }

   /** 
    * Gets the penetration tolerance associated with this behavior.
    * 
    * @return penetration tolerance associated with this behavior
    */
   public double getPenetrationTol() {
      return myPenetrationTol;
   }

   /** 
    * Sets the penetration tolerance associated with this behavior.
    * 
    * @param tol new penetration tolerance
    */
   public void setPenetrationTol (double tol) {
      myPenetrationTol = tol;
      myPenetrationTolMode =
         PropertyUtils.propagateValue (
            this, "penetrationTol", myPenetrationTol, myPenetrationTolMode);      
   }

   public void setPenetrationTolMode (PropertyMode mode) {
      myPenetrationTolMode =
         PropertyUtils.setModeAndUpdate (
            this, "penetrationTol", myPenetrationTolMode, mode);
   }

   public PropertyMode getPenetrationTolMode() {
      return myPenetrationTolMode;
   }

   /** 
    * Gets the contact compliance associated with this behavior.
    * 
    * @return contact compliance
    */
   public double getCompliance() {
      return myCompliance;
   }

   /** 
    * Sets the contact compliance associated with this behavior.
    * 
    * @param c new contact compliance
    */
   public void setCompliance (double c) {
      myCompliance = c;
      myComplianceMode =
         PropertyUtils.propagateValue (
            this, "compliance", myCompliance, myComplianceMode);      
   }

   public void setComplianceMode (PropertyMode mode) {
      myComplianceMode =
         PropertyUtils.setModeAndUpdate (
            this, "compliance", myComplianceMode, mode);
   }

   public PropertyMode getComplianceMode() {
      return myComplianceMode;
   }

   /** 
    * Gets the contact damping associated with this behavior.
    * 
    * @return contact damping
    */
   public double getDamping() {
      return myDamping;
   }

   /** 
    * Sets the contact damping associated with this behavior.
    * 
    * @param d new contact damping
    */
   public void setDamping (double d) {
      myDamping = d;
      myDampingMode =
         PropertyUtils.propagateValue (
            this, "damping", myDamping, myDampingMode);      
   }

   public void setDampingMode (PropertyMode mode) {
      myDampingMode =
         PropertyUtils.setModeAndUpdate (this, "damping", myDampingMode, mode);
   }

   public PropertyMode getDampingMode() {
      return myDampingMode;
   }

   /** 
    * Gets the stiction creep associated with this behavior. See {@link
    * #setStictionCreep}.
    * 
    * @return stiction creep
    */
   public double getStictionCreep() {
      return myStictionCreep;
   }

   /** 
    * Sets the stiction creep associated with this behavior. Stiction creep is
    * the velocity that a nominally stationary contact in ``stiction'' is
    * allowed to move. While the default (and usually desired) value is 0, a
    * value {@code > 0} regularizes the computation of friction forces by
    * removing redundancy.
    * 
    * @param creep new stiction creep
    */
   public void setStictionCreep (double creep) {
      myStictionCreep = creep;
      myStictionCreepMode =
         PropertyUtils.propagateValue (
            this, "stictionCreep", myStictionCreep, myStictionCreepMode);      
   }

   public void setStictionCreepMode (PropertyMode mode) {
      myStictionCreepMode =
         PropertyUtils.setModeAndUpdate (
            this, "stictionCreep", myStictionCreepMode, mode);
   }

   public PropertyMode getStictionCreepMode() {
      return myStictionCreepMode;
   }

   /**
    * Returns the desired collision acceleration. See {@link #setAcceleration}.
    */
   public double getAcceleration() {
      return myAcceleration;
   }

   /**
    * Sets a desired acceleration for collision response which will be used to
    * automatically compute collision compliance if the specified compliance
    * (as returned by {@link #getCompliance}) is zero.
    *
    * <p>This property is currently experimental and not guaranteed to produce
    * reliable results.
    *
    * @param acc desired collision acceleration
    */
   public void setAcceleration (double acc) {
      myAcceleration = acc;
      myAccelerationMode =
      PropertyUtils.propagateValue (
         this, "acceleration", myAcceleration, myAccelerationMode);        
   }

   public void setAccelerationMode (PropertyMode mode) {
      myAccelerationMode =
         PropertyUtils.setModeAndUpdate (
            this, "acceleration", myAccelerationMode, mode);
   }

   public PropertyMode getAccelerationMode() {
      return myAccelerationMode;
   }

   /** 
    * Gets the rigid region tolerance associated with this behavior.
    * 
    * @return rigid region tolerance
    */
   public double getRigidRegionTol() {
      return myRigidRegionTol;
   }

   /** 
    * Sets the rigid region tolerance associated with this behavior.
    * 
    * @param tol new rigid region tolerance
    */
   public void setRigidRegionTol (double tol) {
      myRigidRegionTol = tol;
      myRigidRegionTolMode =
         PropertyUtils.propagateValue (
            this, "rigidRegionTol", myRigidRegionTol, myRigidRegionTolMode);      
   }

   public void setRigidRegionTolMode (PropertyMode mode) {
      myRigidRegionTolMode =
         PropertyUtils.setModeAndUpdate (
            this, "rigidRegionTol", myRigidRegionTolMode, mode);
   }

   public PropertyMode getRigidRegionTolMode() {
      return myRigidRegionTolMode;
   }

   /** 
    * Gets the rigid point tolerance associated with this behavior.  This is
    * the point clustering distance used when computing contact planes.
    * 
    * @return rigid point tolerance
    */
   public double getRigidPointTol() {
      return myRigidPointTol;
   }

   /** 
    * Sets the rigid point tolerance associated with this behavior.
    * 
    * @param tol new rigid point tolerance
    */
   public void setRigidPointTol (double tol) {
      myRigidPointTol = tol;
      myRigidPointTolMode =
         PropertyUtils.propagateValue (
            this, "rigidPointTol", myRigidPointTol, myRigidPointTolMode);      
   }

   public void setRigidPointTolMode (PropertyMode mode) {
      myRigidPointTolMode =
         PropertyUtils.setModeAndUpdate (
            this, "rigidPointTol", myRigidPointTolMode, mode);
   }

   public PropertyMode getRigidPointTolMode() {
      return myRigidPointTolMode;
   }

   public <T extends ContactForceBehavior> void setForceBehavior (T behav) {
      ContactForceBehavior oldBehav = myForceBehavior;
      T newBehav = (T)MaterialBase.updateMaterial (
         this, "forceBehavior", myForceBehavior, behav);
      myForceBehavior = newBehav;
   }
   
   public ContactForceBehavior getForceBehavior() {
      return myForceBehavior;
   }

   /** 
    * Queries whether constraint reduction is enabled for this behavior.
    * 
    * @return true if constraint reduction is enabled
    */
   public boolean getReduceConstraints() {
      return myReduceConstraints;
   }

   /** 
    * Sets whether or not constraint reduction is enabled for this behavior.
    * 
    * @param enable true if constraint reduction should be enabled
    */
   public void setReduceConstraints (boolean enable) {
      myReduceConstraints = enable;
   }

   public void setReduceConstraintsMode (PropertyMode mode) {
      myReduceConstraintsMode =
         PropertyUtils.setModeAndUpdate (
            this, "reduceConstraints", myReduceConstraintsMode, mode);
   }

   public PropertyMode getReduceConstraintsMode() {
      return myReduceConstraintsMode;
   }

   /** 
    * @deprecated Use {@link #getVertexPenetrations()} {@code =
    * VertexPenetrations.BOTH_COLLIDABLES} instead.
    */
   public boolean getBodyFaceContact() {
      return getVertexPenetrations() == VertexPenetrations.BOTH_COLLIDABLES;
   }

   /** 
    * @deprecated Use {@link
    * #setVertexPenetrations}{@code(BOTH_COLLIDABLES)} instead.
    */   
   public void setBodyFaceContact (boolean enable) {
      setVertexPenetrations (VertexPenetrations.BOTH_COLLIDABLES);
   }

   /** 
    * Queries when two-way contact is enabled. See {@link VertexPenetrations} for
    * details.
    * 
    * @return when two-way contact is enabled.
    */
   public VertexPenetrations getVertexPenetrations() {
      return myVertexPenetrations;
   }

   /** 
    * Sets when two-way contact is enabled. See {@link VertexPenetrations} for
    * details.
    * 
    * @param mode specifies when two-way contact is enabled.
    */
   public void setVertexPenetrations (VertexPenetrations mode) {
      myVertexPenetrations = mode;
      myVertexPenetrationsMode =
         PropertyUtils.propagateValue (
            this, "vertexPenetrations",
            myVertexPenetrations, myVertexPenetrationsMode);

   }

   public void setVertexPenetrationsMode (PropertyMode mode) {
      myVertexPenetrationsMode =
         PropertyUtils.setModeAndUpdate (
            this, "vertexPenetrations", myVertexPenetrationsMode, mode);
   }

   public PropertyMode getVertexPenetrationsMode() {
      return myVertexPenetrationsMode;
   }

   public boolean getDrawIntersectionContours() {
      return myDrawIntersectionContours;
   }

   public void setDrawIntersectionContours (boolean enable) {
      myDrawIntersectionContours = enable;
      myDrawIntersectionContoursMode =
         PropertyUtils.propagateValue (
            this, "drawIntersectionContours",
            myDrawIntersectionContours, myDrawIntersectionContoursMode);      
   }

   public void setDrawIntersectionContoursMode (PropertyMode mode) {
      myDrawIntersectionContoursMode =
         PropertyUtils.setModeAndUpdate (
            this, "drawIntersectionContours",
            myDrawIntersectionContoursMode, mode);
   }

   public PropertyMode getDrawIntersectionContoursMode() {
      return myDrawIntersectionContoursMode;
   }

   public boolean getDrawIntersectionFaces() {
      return myDrawIntersectionFaces;
   }

   public void setDrawIntersectionFaces (boolean enable) {
      myDrawIntersectionFaces = enable;
      myDrawIntersectionFacesMode =
         PropertyUtils.propagateValue (
            this, "drawIntersectionFaces",
            myDrawIntersectionFaces, myDrawIntersectionFacesMode);      
   }

   public void setDrawIntersectionFacesMode (PropertyMode mode) {
      myDrawIntersectionFacesMode =
         PropertyUtils.setModeAndUpdate (
            this, "drawIntersectionFaces", myDrawIntersectionFacesMode, mode);
   }

   public PropertyMode getDrawIntersectionFacesMode() {
      return myDrawIntersectionFacesMode;
   }

   public boolean getDrawIntersectionPoints() {
      return myDrawIntersectionPoints;
   }

   public void setDrawIntersectionPoints (boolean enable) {
      myDrawIntersectionPoints = enable;
      myDrawIntersectionPointsMode =
         PropertyUtils.propagateValue (
            this, "drawIntersectionPoints",
            myDrawIntersectionPoints, myDrawIntersectionPointsMode);      
   }

   public void setDrawIntersectionPointsMode (PropertyMode mode) {
      myDrawIntersectionPointsMode =
         PropertyUtils.setModeAndUpdate (
            this, "drawIntersectionPoints", myDrawIntersectionPointsMode, mode);
   }

   public PropertyMode getDrawIntersectionPointsMode() {
      return myDrawIntersectionPointsMode;
   }

   public boolean getDrawContactNormals() {
      return myDrawContactNormals;
   }

   public void setDrawContactNormals (boolean enable) {
      myDrawContactNormals = enable;
      myDrawContactNormalsMode =
         PropertyUtils.propagateValue (
            this, "drawContactNormals",
            myDrawContactNormals, myDrawContactNormalsMode);
   }

   public void setDrawContactNormalsMode (PropertyMode mode) {
      myDrawContactNormalsMode =
         PropertyUtils.setModeAndUpdate (
            this, "drawContactNormals", myDrawContactNormalsMode, mode);
   }

   public PropertyMode getDrawContactNormalsMode() {
      return myDrawContactNormalsMode;
   }

   public boolean getDrawContactForces() {
      return myDrawContactForces;
   }

   public void setDrawContactForces (boolean enable) {
      myDrawContactForces = enable;
      myDrawContactForcesMode =
         PropertyUtils.propagateValue (
            this, "drawContactForces",
            myDrawContactForces, myDrawContactForcesMode);
   }

   public void setDrawContactForcesMode (PropertyMode mode) {
      myDrawContactForcesMode =
         PropertyUtils.setModeAndUpdate (
            this, "drawContactForces", myDrawContactForcesMode, mode);
   }

   public PropertyMode getDrawContactForcesMode() {
      return myDrawContactForcesMode;
   }

   public boolean getDrawFrictionForces() {
      return myDrawFrictionForces;
   }

   public void setDrawFrictionForces (boolean enable) {
      myDrawFrictionForces = enable;
      myDrawFrictionForcesMode =
         PropertyUtils.propagateValue (
            this, "drawFrictionForces",
            myDrawFrictionForces, myDrawFrictionForcesMode);
   }

   public void setDrawFrictionForcesMode (PropertyMode mode) {
      myDrawFrictionForcesMode =
         PropertyUtils.setModeAndUpdate (
            this, "drawFrictionForces", myDrawFrictionForcesMode, mode);
   }

   public PropertyMode getDrawFrictionForcesMode() {
      return myDrawFrictionForcesMode;
   }

   // public boolean getDrawConstraints() {
   //    return myDrawConstraints;
   // }

   // public void setDrawConstraints (boolean enable) {
   //    myDrawConstraints = enable;
   //    myDrawConstraintsMode =
   //       PropertyUtils.propagateValue (
   //          this, "drawConstraints", myDrawConstraints, myDrawConstraintsMode);
   // }

   // public void setDrawConstraintsMode (PropertyMode mode) {
   //    myDrawConstraintsMode =
   //       PropertyUtils.setModeAndUpdate (
   //          this, "drawConstraints", myDrawConstraintsMode, mode);
   // }

   // public PropertyMode getDrawConstraintsMode() {
   //    return myDrawConstraintsMode;
   // }

   /**
    * @deprecated
    * Replaced by the combination of
    * {@link #getDrawColorMap} and {@link getRenderingCollidable}.
    */
   public int getDrawPenetrationDepth() {
      if (getDrawColorMap() == ColorMapType.PENETRATION_DEPTH) {
         return getRenderingCollidable();
      }
      else {
         return -1;
      }
   }

   /**
    * @deprecated
    * Replaced by the combination of
    * {@link #setDrawColorMap} and {@link setRenderingCollidable}.
    */
   public void setDrawPenetrationDepth (int colNum) {
      if (colNum == -1) {
         setDrawColorMap (ColorMapType.NONE);
      }
      else {
         setDrawColorMap (ColorMapType.PENETRATION_DEPTH);
         setRenderingCollidable (colNum);
      }
   }

   /**
    * Added for backwards compatibility. Returns the color map range.
    */
   public ScalarRange getPenetrationDepthRange() {
      return getColorMapRange();
   }

   public void setColorMapRange (ScalarRange range) {
      if (range != null) {
         ScalarRange newRange = range.clone();
         PropertyUtils.updateCompositeProperty (
            this, "colorMapRange", myColorMapRange, newRange);
         myColorMapRange = newRange;        
      }
      else if (myColorMapRange != null) {
         PropertyUtils.updateCompositeProperty (
            this, "colorMapRange", myColorMapRange, null);
         myColorMapRange = null;
      }
   }
   
   public ScalarRange getColorMapRange() {
      return myColorMapRange;
   }

   public void setColorMapInterpolation (ColorInterpolation interp) {
      myColorMapInterpolation = interp;
      myColorMapInterpolationMode =
         PropertyUtils.propagateValue (
            this, "colorMapInterpolation",
            myColorMapInterpolation, myColorMapInterpolationMode);
   }
   
   public ColorInterpolation getColorMapInterpolation() {
      return myColorMapInterpolation;
   }

   public void setColorMapInterpolationMode (PropertyMode mode) {
      myColorMapInterpolationMode =
         PropertyUtils.setModeAndUpdate (
            this, "colorMapInterpolation", myColorMapInterpolationMode, mode);
   }

   public PropertyMode getColorMapInterpolationMode() {
      return myColorMapInterpolationMode;
   }

   public ColorMapType getDrawColorMap() {
      return myDrawColorMap;
   }

   public void setDrawColorMap (ColorMapType type) {
      myDrawColorMap = type;
      myDrawColorMapMode =
         PropertyUtils.propagateValue (
            this, "drawColorMap",
            myDrawColorMap, myDrawColorMapMode);
   }

   public void setDrawColorMapMode (PropertyMode mode) {
      myDrawColorMapMode =
         PropertyUtils.setModeAndUpdate (
            this, "drawColorMap", myDrawColorMapMode, mode);
   }

   public PropertyMode getDrawColorMapMode() {
      return myDrawColorMapMode;
   }

   public int getRenderingCollidable() {
      return myRenderingCollidableNum;
   }

   public void setRenderingCollidable (int colNum) {
      if (colNum != 0 && colNum != 1) {
         throw new InternalErrorException ("colNum must be 0 or 1");
      }
      myRenderingCollidableNum = colNum;
      myRenderingCollidableMode =
         PropertyUtils.propagateValue (
            this, "renderingCollidable",
            myRenderingCollidableNum, myRenderingCollidableMode);
   }

   public void setRenderingCollidableMode (PropertyMode mode) {
      myRenderingCollidableMode =
         PropertyUtils.setModeAndUpdate (
            this, "renderingCollidable", myRenderingCollidableMode, mode);
   }

   public PropertyMode getRenderingCollidableMode() {
      return myRenderingCollidableMode;
   }

   /**
    * @deprecated Use {@link #getRenderingCollidable} instead.
    */
   public int getColorMapCollidable() {
      return getRenderingCollidable();
   }
   
   /**
    * @deprecated Use {@link #setRenderingCollidable} instead.
    */  
   public void setColorMapCollidable (int colNum) {
      setRenderingCollidable (colNum);      
   }

   public boolean isCompliant() {
      return (myCompliance != 0 || myForceBehavior != null);
   }

//   protected boolean scanItem (ReaderTokenizer rtok, Deque<ScanToken> tokens)
//      throws IOException {
//
//      rtok.nextToken();
//      if (scanAttributeName (rtok, "forceBehavior")) {
//         myForceBehavior =
//            (ContactForceBehavior)Scan.scanClassAndObject (rtok, null);
//         return true;
//      }
//      rtok.pushBack();
//      return super.scanItem (rtok, tokens);
//   }
//
//   protected void writeItems (
//      PrintWriter pw, NumberFormat fmt, CompositeComponent ancestor)
//      throws IOException {
//
//      if (myForceBehavior instanceof Scannable) {
//         pw.print ("forceBehavior="+myForceBehavior.getClass().getName());
//         ((Scannable)myForceBehavior).write (pw, fmt, ancestor);
//      }    
//      super.writeItems (pw, fmt, ancestor); 
//   }

   public void set (CollisionBehavior behav) {
      if (behav == this) {
         return;
      }
      myEnabled = behav.myEnabled;
      myFriction = behav.myFriction;
      myFrictionMode = behav.myFrictionMode;
      myMethod = behav.myMethod;
      myMethodMode = behav.myMethodMode;
      myBilateralVertexContact = behav.myBilateralVertexContact;
      myBilateralVertexContactMode = behav.myBilateralVertexContactMode;
      myColliderType = behav.myColliderType;
      myColliderTypeMode = behav.myColliderTypeMode;
      myPenetrationTol = behav.myPenetrationTol;
      myPenetrationTolMode = behav.myPenetrationTolMode;
      myCompliance = behav.myCompliance;
      myComplianceMode = behav.myComplianceMode;
      myDamping = behav.myDamping;
      myDampingMode = behav.myDampingMode;
      myStictionCreep = behav.myStictionCreep;
      myStictionCreepMode = behav.myStictionCreepMode;
      myAcceleration = behav.myAcceleration;
      myAccelerationMode = behav.myAccelerationMode;
      myRigidRegionTol = behav.myRigidRegionTol;
      myRigidRegionTolMode = behav.myRigidRegionTolMode;
      myRigidPointTol = behav.myRigidPointTol;
      myRigidPointTolMode = behav.myRigidPointTolMode;
      myReduceConstraints = behav.myReduceConstraints;
      myReduceConstraintsMode = behav.myReduceConstraintsMode;
      myVertexPenetrations = behav.myVertexPenetrations;
      myVertexPenetrationsMode = behav.myVertexPenetrationsMode;
      myForceBehavior = behav.myForceBehavior; // XXX should we copy?
      myDrawIntersectionContours = behav.myDrawIntersectionContours;
      myDrawIntersectionContoursMode = behav.myDrawIntersectionContoursMode;
      myDrawIntersectionFaces = behav.myDrawIntersectionFaces;
      myDrawIntersectionFacesMode = behav.myDrawIntersectionFacesMode;
      myDrawIntersectionPoints = behav.myDrawIntersectionPoints;
      myDrawIntersectionPointsMode = behav.myDrawIntersectionPointsMode;
      myDrawContactNormals = behav.myDrawContactNormals;
      myDrawContactNormalsMode = behav.myDrawContactNormalsMode;
      myDrawContactForces = behav.myDrawContactForces;
      myDrawContactForcesMode = behav.myDrawContactForcesMode;
      myDrawFrictionForces = behav.myDrawFrictionForces;
      myDrawFrictionForcesMode = behav.myDrawFrictionForcesMode;
      myDrawColorMap = behav.myDrawColorMap;
      myDrawColorMapMode = behav.myDrawColorMapMode;
      myRenderingCollidableNum = behav.myRenderingCollidableNum;
      myRenderingCollidableMode = behav.myRenderingCollidableMode;
      setColorMapRange (behav.getColorMapRange());
      myColorMapInterpolation = behav.myColorMapInterpolation;
      myColorMapInterpolationMode = behav.myColorMapInterpolationMode;
      setRenderProps (behav.myRenderProps);
   }

   /** 
    * Returns true if this behavior equals another. The values
    * returned by {@link #getPair getPair}
    * are not considered in this comparision.
    *
    * <p>This method is mainly used for testing purposes
    * 
    * @param behav behavior to compare with
    * @return true if this behavior equals behav
    */
   boolean equals (CollisionBehavior behav) {
      PropertyMode EXPLICIT = PropertyMode.Explicit;
      if (myEnabled != behav.myEnabled) {
         return false;
      }
      if (myFrictionMode != behav.myFrictionMode) {
         return false;
      }
      else if (myFrictionMode == EXPLICIT &&
               myFriction != behav.myFriction) {
         return false;
      }
      if (myMethodMode != behav.myMethodMode) {
         return false;
      }
      else if (myMethodMode == EXPLICIT &&
               myMethod != behav.myMethod) {
         return false;
      }
      if (myBilateralVertexContactMode != behav.myBilateralVertexContactMode) {
         return false;
      }
      else if (myBilateralVertexContactMode == EXPLICIT &&
               myBilateralVertexContact != behav.myBilateralVertexContact) {
         return false;
      }
      if (myPenetrationTolMode != behav.myPenetrationTolMode) {
         return false;
      }
      else if (myPenetrationTolMode == EXPLICIT &&
               myPenetrationTol != behav.myPenetrationTol) {
         return false;
      }
      if (myComplianceMode != behav.myComplianceMode) {
         return false;
      }
      else if (myComplianceMode == EXPLICIT &&
               myCompliance != behav.myCompliance) {
         return false;
      }
      if (myDampingMode != behav.myDampingMode) {
         return false;
      }
      else if (myDampingMode == EXPLICIT &&
               myDamping != behav.myDamping) {
         return false;
      }
      if (myStictionCreepMode != behav.myStictionCreepMode) {
         return false;
      }
      else if (myStictionCreepMode == EXPLICIT &&
               myStictionCreep != behav.myStictionCreep) {
         return false;
      }
      if (myAccelerationMode != behav.myAccelerationMode) {
         return false;
      }
      else if (myAccelerationMode == EXPLICIT &&
               myAcceleration != behav.myAcceleration) {
         return false;
      }
      if (myRigidRegionTolMode != behav.myRigidRegionTolMode) {
         return false;
      }
      else if (myRigidRegionTolMode == EXPLICIT &&
               myRigidRegionTol != behav.myRigidRegionTol) {
         return false;
      }
      if (myRigidPointTolMode != behav.myRigidPointTolMode) {
         return false;
      }
      else if (myRigidPointTolMode == EXPLICIT &&
               myRigidPointTol != behav.myRigidPointTol) {
         return false;
      }
      if (myReduceConstraintsMode != behav.myReduceConstraintsMode) {
         return false;
      }
      else if (myReduceConstraintsMode == EXPLICIT &&
               myReduceConstraints != behav.myReduceConstraints) {
         return false;
      }
      if (myDrawIntersectionContoursMode!=behav.myDrawIntersectionContoursMode) {
         return false;
      }
      else if (myDrawIntersectionContoursMode == EXPLICIT &&
               myDrawIntersectionContours != behav.myDrawIntersectionContours) {
         return false;
      }
      if (myDrawIntersectionFacesMode != behav.myDrawIntersectionFacesMode) {
         return false;
      }
      else if (myDrawIntersectionFacesMode == EXPLICIT &&
               myDrawIntersectionFaces != behav.myDrawIntersectionFaces) {
         return false;
      }
      if (myDrawIntersectionPointsMode != behav.myDrawIntersectionPointsMode) {
         return false;
      }
      else if (myDrawIntersectionPointsMode == EXPLICIT &&
               myDrawIntersectionPoints != behav.myDrawIntersectionPoints) {
         return false;
      }
      // if (myDrawConstraintsMode != behav.myDrawConstraintsMode) {
      //    return false;
      // }
      // else if (myDrawConstraintsMode == EXPLICIT &&
      //          myDrawConstraints != behav.myDrawConstraints) {
      //    return false;
      // }
      if (myDrawColorMapMode != behav.myDrawColorMapMode) {
         return false;
      }
      else if (myDrawColorMapMode == EXPLICIT &&
               myDrawColorMap != behav.myDrawColorMap) {
         return false;
      }
      if (myRenderingCollidableMode != behav.myRenderingCollidableMode) {
         return false;
      }
      else if (myRenderingCollidableMode == EXPLICIT &&
               myRenderingCollidableNum != behav.myRenderingCollidableNum) {
         return false;
      }
      if ((myForceBehavior==null) != (behav.myForceBehavior==null)) {
         return false;
      }
      else if (myForceBehavior != null) {
         return myForceBehavior.equals (behav.myForceBehavior);
      }
      if (!RenderProps.equals (myRenderProps, behav.myRenderProps)) {
         return false;
      }
      return true;
   }

   // --- begin Renderable interface ---

   public RenderProps getRenderProps() {
      return myRenderProps;
   }

   public void setRenderProps (RenderProps props) {
      myRenderProps =
         RenderableComponentBase.updateRenderProps (this, myRenderProps, props);
   }

   public void prerender (RenderList list) {
   }

   /**
    * Render method for this component is just a stub - it is needed because
    * this class extends RenderableComponentBase, which is done to export the
    * fact that the class has render properties, and also exports them as a
    * property.
    */
   public void render (Renderer renderer, int flags) {
   }

   public void updateBounds (Vector3d pmin, Vector3d pmax) {
   }

   public void getSelection (LinkedList<Object> list, int qid) {
   }
   
   public RenderProps createRenderProps() {
      return RenderProps.createRenderProps (this);
   }

   public int getRenderHints() {
      int code = 0;
      if (myRenderProps != null && myRenderProps.isTransparent()) {
         code |= TRANSPARENT;
      }
      return code;
   }

   /**
    * {@inheritDoc}
    */
   public boolean isSelectable() {
      return true;
   }

   public int numSelectionQueriesNeeded() {
      return -1;
   }

   // ---- end Renderable interface ----

   public void scaleDistance (double s) {
      if (myRigidPointTol != -1) {
         myRigidPointTol *= s;
      }
      if (myRigidRegionTol != -1) {
         myRigidRegionTol *= s;
      }
      myAcceleration *= s;
      myStictionCreep *= s;
      if (myColorMapRange != null) {
         myColorMapRange.scale (s);
      }
      if (myRenderProps != null) {
         myRenderProps.scaleDistance (s);
      }
   }

   public void scaleMass (double s) {
      myCompliance /= s;
      myDamping *= s;
   }   

   /**
    * Queries whether a collidable body matches the first collidable of this
    * behavior.
    */
   public boolean collidable0MatchesBody (CollidableBody cbody) {
     Collidable col0 = getCollidable(0);
      if (!(col0 instanceof Collidable.Group)) {
         if (cbody != col0 && cbody.getCollidableAncestor() != col0) {
            return false;
         }
      }
      return true;
   }

//   /** 
//    * Returns the MechModel responsible for determining this behavior. This
//    * information is not normally set by the application.
//    * 
//    * @return MechModel associated with this behavior
//    */     Collidable b0 = myBehavior.getCollidable(0);
//   public MechModel getModel() {
//      return myModel;
//   }

//   /** 
//    * Returns the collision pair associated with this behavior. This
//    * information is not normally set by the application.
//    * 
//    * @return collision pair associated with this behavior.
//    */
//   public CollidablePair getPair() {
//      return myPair;
//   }
   
}
